{ optiondictionaries.inc - A class to organize and manage command-line options.

  This file is part of linearc.pp, a libray for robust command-line parsing.

  This program is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 3 of the License or, at your
  option, any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABLITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
  License for more details.

  You should have received a copy of the GNU General Public License along
  with this program.  If not, see <http://www.gnu.org/licenses/>.
}
{$IFDEF ReadInterface}
// ACommandLineOptionDictionary ************************************************
{ This class represents a dictionary of command-line options.  It provides a
  way to organize and manage instances of @link(ACommandLineOption) and its
  descendants.

  The dictionary allows new options to be created on the fly, and it also allows
  abbreviations to be defined for those options.  The abbreviated forms of the
  options are inserted into the top level of the underlying tree, like the
  full version of the option, but their @link(ANode.Parent Parent) node pointer
  is set to point to the full version of the option that they represent.  When
  the various value and option lookup routines are called, they automatically
  return the parent if an abbreviated form of the option is requested.
}
type ACommandLineOptionDictionary = class(ASymbolTable)
  public
    // Initializer
    function init: boolean; override;

    { Add a new entry to the dictionary.

      This method is designed allow new options to be constructed on the fly
      and inserted into the dictionary.  If @code(abbreviations) contains one or
      more strings that represent abbreviations for @code(ThisOption), then
      these abbreviations will also be entered into the dictionary.

      As with other instances of @link(ABinaryTree),
      @link(ACommandLineOptionDictionary) does not allow duplicate entries.
      If the new entry has the same name as one already in the list and
      @code(freeOnFailure) is @true, then the new entry will be freed instead of
      being inserted into the list.

      @return(A reference to the dictionary entry that has been created and
      inserted or, if an entry with the same name was already present in the
      list, a reference to that entry.  The caller should NOT attempt to free
      this reference; that will be done when the dictionary is destroyed.)
    }
    function add(const ThisOption: ACommandLineOption;
      const abbreviations: array of string;
      const freeOnFailure: boolean = true): ACommandLineOption; virtual;

    { Print option usage information to the specified stream.

      This method iterates through each option in the dictionary and, so long as
      the option is not an instance of @link(ACommandLineAbbreviation), it calls
      @link(ATextOutputStream.printWrapped Dest.printWrapped) to print the usage
      string generated by a call to @link(ACommandLineOption.usageString).

      @return(The total number of bytes printed to @code(Dest).)
    }
    function printUsageTo(const Dest: ATextOutputStream;
      prefix: AnsiString = ''; suffix: AnsiString = ''): TStreamIOSize;
        virtual;

    { Retrieve a list of all required options.

      This method iterates through each option in the dictionary and, so long as
      the option is not an instance of @link(ACommandLineAbbreviation), it calls
      @link(ACommandLineOption.required) to determine whether or not the option
      is required.  If so, the name of the option is added to the list returned.

      If no options are required, this method will return an empty list.
    }
    function RequiredOptionNames: AStringList; virtual;

    { Retrieve a reference to the first required option that has not been set.

      This method iterates through each option in the dictionary and, so long as
      the option is not an instance of @link(ACommandLineAbbreviation), it calls
      @link(ACommandLineOption.required), to determine if the option is
      required; and, if so, it then calls @link(ACommandLineOption.dirty) to
      determine whether the option has been set by the user.  If
      @link(ACommandLineOption.dirty) returns @false, then a reference to that
      option is returned.

      If all required options have been set, or if there are no required
      options, this method returns @nil.

      The caller should NOT attempt to free the reference returned by this
      routine.
    }
    function FirstCleanRequiredOption: ACommandLineOption; virtual;

    { Retrieve a list of all rest argument names.

      This method iterates through each option in the dictionary and, so long as
      the option is not an instance of @link(ACommandLineAbbreviation), it
      tests to see whether @link(TOptionValueType ovtRest) is in the list of
      flags returned by @link(ACommandLineOption.optionType).  If so, the name
      of the option is added to the list returned.

      If no rest arguments have been specified, this method will return an
      empty list.
    }
    function RestArgumentNames: AStringList; virtual;

    { Retrieve a reference to the first rest argument that has not been set.

      This method iterates through each option in the dictionary and, so long as
      the option is not an instance of @link(ACommandLineAbbreviation), it
      tests to see whether @link(TOptionValueType ovtRest) is in the list of
      flags returned by @link(ACommandLineOption.optionType).  If so, it calls
      @link(ACommandLineOption.dirty) to test whether the option has been set,
      and checks whether @link(TOptionValueType ovtList) is in the list of
      flags returned by @link(ACommandLineOption.optionType).  If the option
      has not been set OR if it is a list option, then a reference to the
      option is returned.

      If no rest arguments have been specified, or if every rest argument has
      been filled, this method will return @nil.
    }
    function FirstCleanRestArgument: ACommandLineOption; virtual;

    { Call handlers for each option that has been dirtied and which also has
      a handler specified for it.

      If any of the handlers returns @false, this method exits immediately and
      returns @false.  This method will only return @true if all handlers
      return @true.
    }
    function handleDirtiedOptions: boolean; virtual;

    // Properties --------------------------------------------------------------
    { Retrieve a reference to the named option.

      @code(key) may refer to the full form or an abbreviated form of the
      desired option.

      @return(A reference to the named option.  The caller should NOT attempt to
      free this reference; that will be done when the dictionary is destroyed.
      If the option specified by @code(key) is not found, this method returns
      @nil.)
    }
    function Option(const key: string): ACommandLineOption; virtual;

    { Retrieve the value of the named option.

      @code(key) may refer to either the full form or an abbreviated form of
      a given option.

      @return(The current value of the option named by @code(key).  If no such
      option was found in the list, this method returns @code(Variants.null).)
    }
    function valueOf(const key: string): Variant; virtual;

    { Retrieve the value of the named option and, if that value is not found,
      return the default value specified.

      @code(key) may refer to either the full form or an abbreviated form of a
      given option.

      @return(The current value of the option named by @code(key).  If no such
      option was found in the list, this method returns @code(defaultValue).)
    }
    function valueOf(const key: string; const defaultValue: Variant): Variant;
      virtual;

    { Set the value of the named option.

      @code(key) may refer to either the full form or an abbreviated form of a
      given option.

      @return(The previous value of the option named by @code(key).  If no such
      option was found in the list, this method returns @code(Variants.null).)
    }
    function setValueOf(const key: string; const newValue: Variant): Variant;
      virtual;
end;
{$ENDIF}
{$IFDEF ReadResourceStrings}
  { This string controls the format of the header printed when
    @link(ACommandLineOptionDictionary.printUsageTo) is called.  It is designed
    to head the list of options and usage information which is printed when
    that method is called.
  }
  clodPrintHeaderRepresentation = 'Options:';
{$ENDIF}
{$IFDEF ReadImplementation}
// ACommandLineOptionDictionary ************************************************
// Initializer
function ACommandLineOptionDictionary.init: boolean;

begin
  result := inherited init;

  if result then
  begin
    // We work with instances of ACommandLineOption, by default
    MyLeafType := ACommandLineOption;
  end;
end;

// Add an option to the dictionary
function ACommandLineOptionDictionary.add(const ThisOption: ACommandLineOption;
  const abbreviations: array of string;
  const freeOnFailure: boolean = true): ACommandLineOption;

var
  // Loop counter
  i: longword;
  // Refers to an abbreviation
  Abbreviation: ACommandLineAbbreviation;

begin
  // Attempt to insert the entry
  Result := ACommandLineOption(Self.insertLeaf(ThisOption));

  // If the insertion failed, then exit
  if Result <> ThisOption then
  begin
    if freeOnFailure then
      ThisOption.free;

    exit;
  end;

  // Add any abbreviations
  if System.length(abbreviations) = 0 then
    exit;

  for i := 0 to System.high(abbreviations) do
  begin
    // Construct the abbreviation
    Abbreviation := ACommandLineAbbreviation.named(abbreviations[i]);

    // Attempt to insert it and, if successful, attach it to the main option
    if ACommandLineAbbreviation(Self.insertLeaf(Abbreviation)) = Abbreviation
      then
    begin
      Result.attach(ANode(ANode.shallowCopyOf(Abbreviation)));
      Abbreviation.MyParent := Result;
    end

    // Otherwise, free it
    else
      Abbreviation.free;
  end;
end;

// Print option usage information to the specified stream
function ACommandLineOptionDictionary.printUsageTo(const Dest: ATextOutputStream;
  prefix: AnsiString = '';
  suffix: AnsiString = ''): TStreamIOSize;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  if prefix = '' then
    prefix := tosWrapDefaultPadCharacter;

  if suffix = '' then
    suffix := bntrDefaultNodePrintingSuffix;

  // Print our header
  result := Dest.printEach([clodPrintHeaderRepresentation, suffix]);

  // Print our entries
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      result := result + Dest.printWrapped(
        ACommandLineOption(ThisEntry).usageString,
        tosWrapDefaultBreakCharacters, 0, 0, clopDescriptionColumn,
        prefix, suffix);

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Retrieve a list of required arguments
function ACommandLineOptionDictionary.RequiredOptionNames: AStringList;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  Result := AStringList.new;
  if Result = nil then
    exit;

  // Loop through each entry
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      if ACommandLineOption(ThisEntry).required then
        Result.add(ThisEntry.name);

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Find the first unset required option
function ACommandLineOptionDictionary.FirstCleanRequiredOption: ACommandLineOption;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  Result := nil;

  // Loop through each entry
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      if (ACommandLineOption(ThisEntry).required) and
        (ACommandLineOption(ThisEntry).dirty = false) then
      begin
        Result := ACommandLineOption(ThisEntry);
        break;
      end;

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Retrieve a list of rest argument names
function ACommandLineOptionDictionary.RestArgumentNames: AStringList;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  Result := AStringList.new;
  if Result = nil then
    exit;

  // Loop through each entry
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      if ovtRest in ACommandLineOption(ThisEntry).optionType then
        Result.add(ThisEntry.name);

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Retrieve the first unset rest argument
function ACommandLineOptionDictionary.FirstCleanRestArgument: ACommandLineOption;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  Result := nil;

  // Loop through each entry
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      if ovtRest in ACommandLineOption(ThisEntry).optionType then
        if (ACommandLineOption(ThisEntry).dirty = false) or
          (ovtList in ACommandLineOption(ThisEntry).optionType) then
        begin
          Result := ACommandLineOption(ThisEntry);
          break;
        end;

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Handle dirtied options that have handlers attached to them
function ACommandLineOptionDictionary.handleDirtiedOptions: boolean;

var
  // Refers to an entry
  ThisEntry: AStringLeaf;

begin
  result := true;

  // Loop through each entry
  ThisEntry := AStringLeaf(MyRoot);

  while ThisEntry <> nil do
  begin
    if not(ThisEntry is ACommandLineAbbreviation) then
      if (ACommandLineOption(ThisEntry).dirty) and
        (ACommandLineOption(ThisEntry).optionDirtiedHandler <> nil) then
        result := ACommandLineOption(ThisEntry).optionDirtiedHandler()(ACommandLineOption(ThisEntry));

    if result = false then
      break;

    ThisEntry := AStringLeaf(ThisEntry.Next);
  end;
end;

// Properties ------------------------------------------------------------------
// Retrieve a reference to the named option
function ACommandLineOptionDictionary.Option(const key: string): ACommandLineOption;

var
  // Refers to the option in question
  ThisOption: AStringLeaf;

begin
  Result := nil;

  ThisOption := AStringLeaf(Self.fetchLeaf(key));
  if ThisOption = nil then
    exit;

  // Do we have an abbreviation or the actual option
  if ThisOption is ACommandLineAbbreviation then
  begin
    Result := ACommandLineOption(ThisOption.Parent)
  end

  else
    Result := ACommandLineOption(ThisOption);
end;

// Retrieve the current value of the named option
function ACommandLineOptionDictionary.valueOf(const key: string): Variant;

var
  // Refers to the option in question
  ThisOption: ACommandLineOption;

begin
  result := Variants.null;

  ThisOption := Self.Option(key);
  if ThisOption = nil then
    exit;

  result := ThisOption.value;
end;

// Retrieve the current value of the named option
function ACommandLineOptionDictionary.valueOf(const key: string;
  const defaultValue: Variant): Variant;

var
  // Refers to the option in question
  ThisOption: ACommandLineOption;

begin
  result := defaultValue;

  ThisOption := Self.Option(key);
  if ThisOption = nil then
    exit;

  result := ThisOption.value;
end;

// Set the value of the named option
function ACommandLineOptionDictionary.setValueOf(const key: string;
  const newValue: Variant): Variant;

var
  // Refers to the option in question
  ThisOption: ACommandLineOption;

begin
  result := Variants.null;

  ThisOption := Self.Option(key);
  if ThisOption = nil then
    exit;

  result := ThisOption.setValue(newValue);
end;
{$ENDIF}
